subsetedDataFrameList = lapply (fileList, columnSubsetFunc)
# rbind them into on data frame
rbindedDataFrame = rbindlist(subsetedDataFrameList)
# remove the "\xa0" in the species names
# Convert to UTF-8 to handle invalid characters
rbindedDataFrame$SpeciesName <- iconv(rbindedDataFrame$SpeciesName, from = "latin1", to = "UTF-8", sub = "byte")
rbindedDataFrame$SpeciesName = gsub("[^[:alnum:] ]", "", rbindedDataFrame$SpeciesName)
#  This part is using the TNRS (The TNRS database and R package) to do the binomial correction and family name allocation.
# get the unique name in the rbindedDataFrame
uniqueSpeciesTable = data.frame (SpeciesID = c(1:length(unique(rbindedDataFrame$SpeciesName))),Family=NA,SpeciesName = unique(rbindedDataFrame$SpeciesName)) %>% mutate_if(is.factor, as.character)
rowNameFormatingTNRS_Func = function(ro)
# for (ro in 1:nrow(uniqueSpeciesTable))
{
# get the data for per row
perRow = uniqueSpeciesTable[ro,]
print(ro)
if (str_count(perRow$SpeciesName,"\xa0")==1)
{
perRow$SpeciesName = gsub("\xa0"," ",perRow$SpeciesName)
}
# check the the space numbers in the speciesName
if (str_count(perRow$SpeciesName," ") >1)
{
# find the second space position
secondSpacePostion = as.data.frame(str_locate_all(perRow$SpeciesName," "))$start[2]
# subset the speciename form the start to the second space
perRow$SpeciesName = substr(perRow$SpeciesName,start=1,stop=(secondSpacePostion-1))
}
# check the family name by TNRS
allocatedInfo = TNRS(perRow$SpeciesName)
if (nchar(allocatedInfo$Name_matched_accepted_family)>4&!is.na(allocatedInfo$Name_matched_accepted_family)&allocatedInfo$Name_matched_accepted_family!=''&!is.null(allocatedInfo$Name_matched_accepted_family))
{
perRow$Family = allocatedInfo$Name_matched_accepted_family
}else
{
perRow$Family = NA
}
# allocate the information to the perRow
perRow$Genus = allocatedInfo$Genus_matched
perRow$Species = allocatedInfo$Specific_epithet_matched
perRow$Binomial = paste(perRow$Genus,perRow$Species,sep=" ")
# show the output
# print(perRow)
return(perRow)
# rbindedDataFrame[ro,] = perRow
}
# Detect number of available cores
num_cores <- parallel::detectCores() - 1  # Leave 1 core free
# Create a cluster
cl <- makeCluster(num_cores/3)
# Export necessary variables and functions to the cluster
clusterExport(cl, varlist = c("uniqueSpeciesTable", "rowNameFormatingTNRS_Func"), envir = environment())
# Load necessary libraries in each worker
clusterEvalQ(cl, {
library(stringr)
library(taxize)
})
# Apply the function in parallel
system.time({
outputList <- parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
})
install.packages("TNRS")
library(TNRS)
# STEP 2: Test TNRS functionality
# Test with a simple example first
test_result <- TNRS("Quercus robur")
print(test_result)
# library(taxize)
remotes::install_github("cran/TNRS")
# res <- tnrs("Quercus robur")
# print(res)
library(dplyr)
# set the working directory
setwd("P:/langara/term 1/DANA-4800-001 - Data Analysis and Stat Infer  20287.202520/project1a/14054077 (1)/Data")
# list the wood density reference data frames
fileList = list.files(path="Data/ReferenceWoodDensityCSVs",pattern= ".csv")
# write a smmall function which only get the columns for Family, SpeciesName,Wood density
columnSubsetFunc = function(filename)
{
# load the single data frame
singleDF = fread(paste("Data/ReferenceWoodDensityCSVs/",filename,sep=""))
# subseting the data frame
returnDataFrame = singleDF[,c("Family","SpeciesName","WoodDensity")]
returnDataFrame$DataSource = gsub(".csv", "", filename)
print(nrow(returnDataFrame))
# retrun it
return(returnDataFrame)
}
# lapply to do the subseting process
subsetedDataFrameList = lapply (fileList, columnSubsetFunc)
# rbind them into on data frame
rbindedDataFrame = rbindlist(subsetedDataFrameList)
# remove the "\xa0" in the species names
# Convert to UTF-8 to handle invalid characters
rbindedDataFrame$SpeciesName <- iconv(rbindedDataFrame$SpeciesName, from = "latin1", to = "UTF-8", sub = "byte")
rbindedDataFrame$SpeciesName = gsub("[^[:alnum:] ]", "", rbindedDataFrame$SpeciesName)
#  This part is using the TNRS (The TNRS database and R package) to do the binomial correction and family name allocation.
# get the unique name in the rbindedDataFrame
uniqueSpeciesTable = data.frame (SpeciesID = c(1:length(unique(rbindedDataFrame$SpeciesName))),Family=NA,SpeciesName = unique(rbindedDataFrame$SpeciesName)) %>% mutate_if(is.factor, as.character)
rowNameFormatingTNRS_Func = function(ro)
# for (ro in 1:nrow(uniqueSpeciesTable))
{
# get the data for per row
perRow = uniqueSpeciesTable[ro,]
print(ro)
if (str_count(perRow$SpeciesName,"\xa0")==1)
{
perRow$SpeciesName = gsub("\xa0"," ",perRow$SpeciesName)
}
# check the the space numbers in the speciesName
if (str_count(perRow$SpeciesName," ") >1)
{
# find the second space position
secondSpacePostion = as.data.frame(str_locate_all(perRow$SpeciesName," "))$start[2]
# subset the speciename form the start to the second space
perRow$SpeciesName = substr(perRow$SpeciesName,start=1,stop=(secondSpacePostion-1))
}
# check the family name by TNRS
allocatedInfo = TNRS(perRow$SpeciesName)
if (nchar(allocatedInfo$Name_matched_accepted_family)>4&!is.na(allocatedInfo$Name_matched_accepted_family)&allocatedInfo$Name_matched_accepted_family!=''&!is.null(allocatedInfo$Name_matched_accepted_family))
{
perRow$Family = allocatedInfo$Name_matched_accepted_family
}else
{
perRow$Family = NA
}
# allocate the information to the perRow
perRow$Genus = allocatedInfo$Genus_matched
perRow$Species = allocatedInfo$Specific_epithet_matched
perRow$Binomial = paste(perRow$Genus,perRow$Species,sep=" ")
# show the output
# print(perRow)
return(perRow)
# rbindedDataFrame[ro,] = perRow
}
# Detect number of available cores
num_cores <- parallel::detectCores() - 1  # Leave 1 core free
# Create a cluster
cl <- makeCluster(num_cores/3)
# Export necessary variables and functions to the cluster
clusterExport(cl, varlist = c("uniqueSpeciesTable", "rowNameFormatingTNRS_Func"), envir = environment())
# Load necessary libraries in each worker
clusterEvalQ(cl, {
library(stringr)
library(taxize)
})
# Apply the function in parallel
system.time({
outputList <- parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
})
library(data.table)
# install.packages("Rcpp")
# install.packages("terra")
# install.packages("raster")
library(raster)
library(stringr)
library(parallel)
# library(Taxonstand) #TPL
# install.packages("remotes")
# install.packages("taxize")
# install.packages(TNRS)
# Instala devtools si no lo tienes
# install.packages("devtools")
library(devtools)
install.packages("TNRS")
# install.packages("TNRS")
library(TNRS)
# install.packages("TNRS")
library(TNRS)
# STEP 2: Test TNRS functionality
# Test with a simple example first
test_result <- TNRS("Quercus robur")
print(test_result)
# library(taxize)
remotes::install_github("cran/TNRS")
# install.packages("TNRS")
library(TNRS)
install.packages("TNRS")
# install.packages("TNRS")
library(TNRS)
# STEP 2: Test TNRS functionality
# Test with a simple example first
test_result <- TNRS("Quercus robur")
print(test_result)
# library(taxize)
# remotes::install_github("cran/TNRS")
# res <- tnrs("Quercus robur")
# print(res)
library(dplyr)
# set the working directory
setwd("P:/langara/term 1/DANA-4800-001 - Data Analysis and Stat Infer  20287.202520/project1a/14054077 (1)/Data")
# list the wood density reference data frames
fileList = list.files(path="Data/ReferenceWoodDensityCSVs",pattern= ".csv")
# write a smmall function which only get the columns for Family, SpeciesName,Wood density
columnSubsetFunc = function(filename)
{
# load the single data frame
singleDF = fread(paste("Data/ReferenceWoodDensityCSVs/",filename,sep=""))
# subseting the data frame
returnDataFrame = singleDF[,c("Family","SpeciesName","WoodDensity")]
returnDataFrame$DataSource = gsub(".csv", "", filename)
print(nrow(returnDataFrame))
# retrun it
return(returnDataFrame)
}
# lapply to do the subseting process
subsetedDataFrameList = lapply (fileList, columnSubsetFunc)
# rbind them into on data frame
rbindedDataFrame = rbindlist(subsetedDataFrameList)
# remove the "\xa0" in the species names
# Convert to UTF-8 to handle invalid characters
rbindedDataFrame$SpeciesName <- iconv(rbindedDataFrame$SpeciesName, from = "latin1", to = "UTF-8", sub = "byte")
rbindedDataFrame$SpeciesName = gsub("[^[:alnum:] ]", "", rbindedDataFrame$SpeciesName)
#  This part is using the TNRS (The TNRS database and R package) to do the binomial correction and family name allocation.
# get the unique name in the rbindedDataFrame
uniqueSpeciesTable = data.frame (SpeciesID = c(1:length(unique(rbindedDataFrame$SpeciesName))),Family=NA,SpeciesName = unique(rbindedDataFrame$SpeciesName)) %>% mutate_if(is.factor, as.character)
rowNameFormatingTNRS_Func = function(ro)
# for (ro in 1:nrow(uniqueSpeciesTable))
{
# get the data for per row
perRow = uniqueSpeciesTable[ro,]
print(ro)
if (str_count(perRow$SpeciesName,"\xa0")==1)
{
perRow$SpeciesName = gsub("\xa0"," ",perRow$SpeciesName)
}
# check the the space numbers in the speciesName
if (str_count(perRow$SpeciesName," ") >1)
{
# find the second space position
secondSpacePostion = as.data.frame(str_locate_all(perRow$SpeciesName," "))$start[2]
# subset the speciename form the start to the second space
perRow$SpeciesName = substr(perRow$SpeciesName,start=1,stop=(secondSpacePostion-1))
}
# check the family name by TNRS
allocatedInfo = TNRS(perRow$SpeciesName)
if (nchar(allocatedInfo$Name_matched_accepted_family)>4&!is.na(allocatedInfo$Name_matched_accepted_family)&allocatedInfo$Name_matched_accepted_family!=''&!is.null(allocatedInfo$Name_matched_accepted_family))
{
perRow$Family = allocatedInfo$Name_matched_accepted_family
}else
{
perRow$Family = NA
}
# allocate the information to the perRow
perRow$Genus = allocatedInfo$Genus_matched
perRow$Species = allocatedInfo$Specific_epithet_matched
perRow$Binomial = paste(perRow$Genus,perRow$Species,sep=" ")
# show the output
# print(perRow)
return(perRow)
# rbindedDataFrame[ro,] = perRow
}
# Detect number of available cores
num_cores <- parallel::detectCores() - 1  # Leave 1 core free
# Create a cluster
cl <- makeCluster(num_cores/3)
# Export necessary variables and functions to the cluster
clusterExport(cl, varlist = c("uniqueSpeciesTable", "rowNameFormatingTNRS_Func"), envir = environment())
# Load necessary libraries in each worker
clusterEvalQ(cl, {
library(stringr)
library(taxize)
})
# Apply the function in parallel
system.time({
outputList <- parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
})
library(parallel)
# set the working directory
setwd("P:/langara/term 1/DANA-4800-001 - Data Analysis and Stat Infer  20287.202520/project1a/14054077 (1)/Data")
# list the wood density reference data frames
fileList = list.files(path="Data/ReferenceWoodDensityCSVs",pattern= ".csv")
# write a smmall function which only get the columns for Family, SpeciesName,Wood density
columnSubsetFunc = function(filename)
{
# load the single data frame
singleDF = fread(paste("Data/ReferenceWoodDensityCSVs/",filename,sep=""))
# subseting the data frame
returnDataFrame = singleDF[,c("Family","SpeciesName","WoodDensity")]
returnDataFrame$DataSource = gsub(".csv", "", filename)
print(nrow(returnDataFrame))
# retrun it
return(returnDataFrame)
}
# lapply to do the subseting process
subsetedDataFrameList = lapply (fileList, columnSubsetFunc)
# rbind them into on data frame
rbindedDataFrame = rbindlist(subsetedDataFrameList)
# remove the "\xa0" in the species names
# Convert to UTF-8 to handle invalid characters
rbindedDataFrame$SpeciesName <- iconv(rbindedDataFrame$SpeciesName, from = "latin1", to = "UTF-8", sub = "byte")
rbindedDataFrame$SpeciesName = gsub("[^[:alnum:] ]", "", rbindedDataFrame$SpeciesName)
#  This part is using the TNRS (The TNRS database and R package) to do the binomial correction and family name allocation.
# get the unique name in the rbindedDataFrame
uniqueSpeciesTable = data.frame (SpeciesID = c(1:length(unique(rbindedDataFrame$SpeciesName))),Family=NA,SpeciesName = unique(rbindedDataFrame$SpeciesName)) %>% mutate_if(is.factor, as.character)
rowNameFormatingTNRS_Func = function(ro)
# for (ro in 1:nrow(uniqueSpeciesTable))
{
# get the data for per row
perRow = uniqueSpeciesTable[ro,]
print(ro)
if (str_count(perRow$SpeciesName,"\xa0")==1)
{
perRow$SpeciesName = gsub("\xa0"," ",perRow$SpeciesName)
}
# check the the space numbers in the speciesName
if (str_count(perRow$SpeciesName," ") >1)
{
# find the second space position
secondSpacePostion = as.data.frame(str_locate_all(perRow$SpeciesName," "))$start[2]
# subset the speciename form the start to the second space
perRow$SpeciesName = substr(perRow$SpeciesName,start=1,stop=(secondSpacePostion-1))
}
# check the family name by TNRS
allocatedInfo = TNRS(perRow$SpeciesName)
if (nchar(allocatedInfo$Name_matched_accepted_family)>4&!is.na(allocatedInfo$Name_matched_accepted_family)&allocatedInfo$Name_matched_accepted_family!=''&!is.null(allocatedInfo$Name_matched_accepted_family))
{
perRow$Family = allocatedInfo$Name_matched_accepted_family
}else
{
perRow$Family = NA
}
# allocate the information to the perRow
perRow$Genus = allocatedInfo$Genus_matched
perRow$Species = allocatedInfo$Specific_epithet_matched
perRow$Binomial = paste(perRow$Genus,perRow$Species,sep=" ")
# show the output
# print(perRow)
return(perRow)
# rbindedDataFrame[ro,] = perRow
}
# Detect number of available cores
num_cores <- parallel::detectCores() - 1  # Leave 1 core free
# Create a cluster
cl <- makeCluster(num_cores/3)
# Export necessary variables and functions to the cluster
clusterExport(cl, varlist = c("uniqueSpeciesTable", "rowNameFormatingTNRS_Func"), envir = environment())
# Load necessary libraries in each worker
clusterEvalQ(cl, {
library(stringr)
library(taxize)
})
# Apply the function in parallel
system.time({
outputList <- parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
})
library(data.table)
# install.packages("Rcpp")
# install.packages("terra")
# install.packages("raster")
library(raster)
library(stringr)
library(parallel)
# library(Taxonstand) #TPL
# install.packages("remotes")
# install.packages("taxize")
# install.packages(TNRS)
# Instala devtools si no lo tienes
# install.packages("devtools")
library(devtools)
# install.packages("TNRS")
library(TNRS)
# STEP 2: Test TNRS functionality
# Test with a simple example first
test_result <- TNRS("Quercus robur")
print(test_result)
# library(taxize)
# remotes::install_github("cran/TNRS")
# res <- tnrs("Quercus robur")
# print(res)
library(dplyr)
# set the working directory
setwd("P:/langara/term 1/DANA-4800-001 - Data Analysis and Stat Infer  20287.202520/project1a/14054077 (1)/Data")
# list the wood density reference data frames
fileList = list.files(path="Data/ReferenceWoodDensityCSVs",pattern= ".csv")
# write a smmall function which only get the columns for Family, SpeciesName,Wood density
columnSubsetFunc = function(filename)
{
# load the single data frame
singleDF = fread(paste("Data/ReferenceWoodDensityCSVs/",filename,sep=""))
# subseting the data frame
returnDataFrame = singleDF[,c("Family","SpeciesName","WoodDensity")]
returnDataFrame$DataSource = gsub(".csv", "", filename)
print(nrow(returnDataFrame))
# retrun it
return(returnDataFrame)
}
# lapply to do the subseting process
subsetedDataFrameList = lapply (fileList, columnSubsetFunc)
# rbind them into on data frame
rbindedDataFrame = rbindlist(subsetedDataFrameList)
# remove the "\xa0" in the species names
# Convert to UTF-8 to handle invalid characters
rbindedDataFrame$SpeciesName <- iconv(rbindedDataFrame$SpeciesName, from = "latin1", to = "UTF-8", sub = "byte")
rbindedDataFrame$SpeciesName = gsub("[^[:alnum:] ]", "", rbindedDataFrame$SpeciesName)
#  This part is using the TNRS (The TNRS database and R package) to do the binomial correction and family name allocation.
# get the unique name in the rbindedDataFrame
uniqueSpeciesTable = data.frame (SpeciesID = c(1:length(unique(rbindedDataFrame$SpeciesName))),Family=NA,SpeciesName = unique(rbindedDataFrame$SpeciesName)) %>% mutate_if(is.factor, as.character)
rowNameFormatingTNRS_Func = function(ro)
# for (ro in 1:nrow(uniqueSpeciesTable))
{
# get the data for per row
perRow = uniqueSpeciesTable[ro,]
print(ro)
if (str_count(perRow$SpeciesName,"\xa0")==1)
{
perRow$SpeciesName = gsub("\xa0"," ",perRow$SpeciesName)
}
# check the the space numbers in the speciesName
if (str_count(perRow$SpeciesName," ") >1)
{
# find the second space position
secondSpacePostion = as.data.frame(str_locate_all(perRow$SpeciesName," "))$start[2]
# subset the speciename form the start to the second space
perRow$SpeciesName = substr(perRow$SpeciesName,start=1,stop=(secondSpacePostion-1))
}
# check the family name by TNRS
allocatedInfo = TNRS(perRow$SpeciesName)
if (nchar(allocatedInfo$Name_matched_accepted_family)>4&!is.na(allocatedInfo$Name_matched_accepted_family)&allocatedInfo$Name_matched_accepted_family!=''&!is.null(allocatedInfo$Name_matched_accepted_family))
{
perRow$Family = allocatedInfo$Name_matched_accepted_family
}else
{
perRow$Family = NA
}
# allocate the information to the perRow
perRow$Genus = allocatedInfo$Genus_matched
perRow$Species = allocatedInfo$Specific_epithet_matched
perRow$Binomial = paste(perRow$Genus,perRow$Species,sep=" ")
# show the output
# print(perRow)
return(perRow)
# rbindedDataFrame[ro,] = perRow
}
# Detect number of available cores
num_cores <- parallel::detectCores() - 1  # Leave 1 core free
# Create a cluster
cl <- makeCluster(num_cores/3)
# Export necessary variables and functions to the cluster
clusterExport(cl, varlist = c("uniqueSpeciesTable", "rowNameFormatingTNRS_Func"), envir = environment())
# Load necessary libraries in each worker
clusterEvalQ(cl, {
library(stringr)
library(taxize)
})
# Apply the function in parallel
system.time({
outputList <- parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
})
# Stop the cluster
stopCluster(cl)# rbindlist
# outputList <- parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
outputList <- parallel::parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
# Apply the function in parallel
system.time({
# outputList <- parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
outputList <- parallel::parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
})
# Detect number of available cores
num_cores <- parallel::detectCores() - 1  # Leave 1 core free
# Create a cluster
cl <- makeCluster(num_cores/3)
# Export necessary variables and functions to the cluster
clusterExport(cl, varlist = c("uniqueSpeciesTable", "rowNameFormatingTNRS_Func"), envir = environment())
# Load necessary libraries in each worker
clusterEvalQ(cl, {
library(stringr)
library(taxize)
})
# Create a cluster
cl <- makeCluster(num_cores/3)
# Export necessary variables and functions to the cluster
clusterExport(cl, varlist = c("uniqueSpeciesTable", "rowNameFormatingTNRS_Func"), envir = environment())
# Load necessary libraries in each worker
clusterEvalQ(cl, {
library(stringr)
library(parallel)
library(TNRS)
})
# Apply the function in parallel
system.time({
# outputList <- parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
outputList <- parallel::parLapply(cl, 1:nrow(uniqueSpeciesTable), rowNameFormatingTNRS_Func)
})
nameAllocatedDataFrame = rbindlist(outputList)
# Stop the cluster
stopCluster(cl)# rbindlist
nameAllocatedDataFrame = rbindlist(outputList)
# merge this table with the rbindedDataFrame
mergedWoodDensityTable = merge(rbindedDataFrame %>% select(SpeciesName,WoodDensity), nameAllocatedDataFrame %>% select(Family,SpeciesName,Genus,Species,Binomial), by="SpeciesName") %>% filter(WoodDensity <2)
View(subsetedDataFrameList)
# Stop the cluster
stopCluster(cl)# rbindlist
nameAllocatedDataFrame = rbindlist(outputList)
# merge this table with the rbindedDataFrame
mergedWoodDensityTable = merge(rbindedDataFrame %>% select(SpeciesName,WoodDensity), nameAllocatedDataFrame %>% select(Family,SpeciesName,Genus,Species,Binomial), by="SpeciesName") %>% filter(WoodDensity <2)
write.csv(mergedWoodDensityTable,"Data/Resources/Wood_density_Table_with_Family_allocated_TNRS_2024.csv")
# merge this table with the rbindedDataFrame
mergedWoodDensityTable = merge(rbindedDataFrame %>% select(SpeciesName,WoodDensity), nameAllocatedDataFrame %>% select(Family,SpeciesName,Genus,Species,Binomial), by="SpeciesName") %>% filter(WoodDensity <2)
# merge this table with the rbindedDataFrame
# mergedWoodDensityTable = merge(rbindedDataFrame %>% select(SpeciesName,WoodDensity), nameAllocatedDataFrame %>% select(Family,SpeciesName,Genus,Species,Binomial), by="SpeciesName") %>% filter(WoodDensity <2)
mergedWoodDensityTable = merge(
as.data.frame(rbindedDataFrame) %>% select(SpeciesName, WoodDensity),
as.data.frame(nameAllocatedDataFrame) %>% select(Family, SpeciesName, Genus, Species, Binomial),
by = "SpeciesName"
) %>% filter(WoodDensity < 2)
mergedWoodDensityTable = merge(
dplyr::select(as.data.frame(rbindedDataFrame), SpeciesName, WoodDensity),
dplyr::select(as.data.frame(nameAllocatedDataFrame), Family, SpeciesName, Genus, Species, Binomial),
by = "SpeciesName"
) %>% dplyr::filter(WoodDensity < 2)
write.csv(mergedWoodDensityTable,"Data/Resources/Wood_density_Table_with_Family_allocated_TNRS_2024_Demo.csv")
